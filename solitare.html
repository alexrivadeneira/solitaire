<!DOCTYPE html>
<html>
<head>
    <style>
        body{
            background: green;
        }


        .board{
            display: flex;
            flex-wrap: wrap;
        }

        .pile{
            display: flex;
            width: 100px;
            margin: 5px;
            flex-direction: column;
        }

        .card{
            width: 73px;
            height: 98px;
            /* border: 1px solid #000; */
            /* border-radius: 15px; */
            margin: 5px;
            background: url('card_back.png');
            background-size:contain;
        }

        .exposed{
            background: url('card-imgs.png');
        }

        .card:not(:first-child){
            margin-top: -78px;
        }

        .stacks{
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .stack{
            width: 73px;
            height: 98px;
            border: 2px solid #fff;
            margin: 10px;
        }


    </style>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
</head>
<body>

    <div class="stacks">
        <div 
            id="0" 
            ondragstart="event.dataTransfer.setData('text/plain', this.id);selectedPile = this.id;"         
            ondragover="currDraggedOverStack = this.id; return false;"
            ondrop="handleStackDrop()"
        class="stack c-stack"></div>
        <div 
            id="1"
            class="stack s-stack">
        </div>
        <div 
            id="2"
            class="stack h-stack">
        </div>
        <div 
            id="3"
            class="stack d-stack">
        </div>
    </div>


    <div class="board">

        <div 
        class="pile" 
        id="0" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >
        </div>

        <div 
        class="pile" 
        id="1" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >
        </div>

        <div 
        class="pile" 
        id="2" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >    
        </div>

        <div 
        class="pile" 
        id="3" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >        
        </div>

        <div 
        class="pile" 
        id="4" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >      
        </div>

        <div 
        class="pile" 
        id="5" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >       
        </div>

        <div 
        class="pile" 
        id="6" 
        ondragstart="event.dataTransfer.setData('text/plain', this.id); selectedPile = this.id;"         ondragover="currDraggedOverPile = this.id; return false;"
        ondrop="handleDrop()"
        >       
        </div>


    </div>

<script>
    const suits = ['h', 'd', 's', 'c'];
    const values = [0,1,2,3,4,5,6,7,8,9,10,11,12];

    let piles = [[],[],[],[],[],[],[]];
    let drawPool = [];

    let selectedPile = null;
    let currDraggedOverPile = null;
    let currDraggedOverStack = null;

    let stacks = [[],[],[],[]]

    const CARD_SIZE = [98, 73];
    const CARD_CENTER = [36.5, 49];

    function getBackgroundCoordsForCard(suit, value){
        const convertSuitToPosValue = {
            c: 0,
            s: 1,
            h: 2,
            d: 3
        };
        const suitValue = convertSuitToPosValue[suit];
        return [-CARD_SIZE[0] * suitValue, -CARD_SIZE[1] * value];
    }

    function updateStacks(stack, card){
        stacks[stack] = card;
    }

    function drawStacks(stacks){
        var stacksDOM = document.querySelectorAll('.stack');
        // first clear anything in the piles so we don't keep adding duplicate cards
        stacks.forEach((stack, index) => {
            stacksDOM[index].innerHTML = '';
        });

        stacks.forEach((stack, index) => {

            if(stack.length === 0){
                stacksDOM[index].innerHTML = '';
            } else {
                var coords = getBackgroundCoordsForCard(stack[0][0], stack[0][1]);
                stacksDOM.innerHTML += `
                    <div class='card' style='background: url("card-imgs.png"); background-position-y:${coords[0]}px; background-position-x:${coords[1]}px;' draggable='true'>
                            <strong><span style="color: #bada55; background: #000;">${card[0]} ${card[1]}</span></strong>

                        </div>
                `;
            }


        });


    }



    // still need to account for whether or not card is visible



    


    // display the sorted cards

    function init(){
        var boardDOM = document.querySelector('.board');
        const deck = [];

        suits.forEach(suit => {
        values.forEach(value =>{
            deck.push([suit, value]);
        });
    });

        const shuffledDeck = shuffleDeck(deck);
        dealPiles(piles, shuffledDeck);

    }

    function shuffleDeck(deck){
        let unshuffledDeck = [...deck];
        let shuffledDeck = [];
        while(unshuffledDeck.length > 0){
            let randomSelect = Math.floor(Math.random() * unshuffledDeck.length);
            shuffledDeck.push(unshuffledDeck[randomSelect]);
            unshuffledDeck.splice(randomSelect, 1);
        }
        return shuffledDeck;
    }

    // sort the cards into piles - 7 piles, and which is on the top
    function dealPiles(piles, deck){
        piles.forEach(function(pile, index){
            var doTimes = index;
            for(var i = 0; i <= doTimes; i++){
                piles[index].push(deck.pop());
            }
        });
    }

    function setStateSelectedPile(e){
        selectedPile = e.id; 
        // console.log("@@@ selected pile", selectedPile);
    }

    function drawPiles(piles){
        var pilesDOM = document.querySelectorAll('.pile');
        // first clear anything in the piles so we don't keep adding duplicate cards
        piles.forEach((pile, index) => {
            pilesDOM[index].innerHTML = '';
        });

        piles.forEach((pile, index) => {
            pile.forEach((card, idx) => {
                // expose last card
                if(idx === pile.length - 1){

                    var coords = getBackgroundCoordsForCard(card[0], card[1]);
                    pilesDOM[index].innerHTML += 
                `
                        <div class='card' style='background: url("card-imgs.png"); background-position-y:${coords[0]}px; background-position-x:${coords[1]}px;' draggable='true'>
                            <strong><span style="color: #bada55; background: #000;">${card[0]} ${card[1]}</span></strong>

                        </div>
                `;
                } else {
                    pilesDOM[index].innerHTML += 
                `
                        <div class='card ${card[0] === ('c' || 's') ? 'red' : 'black'}' draggable='true'>
                        </div>
                `;
                }

            });
        });
    }

    function handleDragOver(e){
        // console.log('drag over event');
        // console.log("drag over: ", e);
        // console.log(e.id)
        currDraggedOverPile = e.id;
    }

    function handleDropCardOnNewPile(pileFromIdx, pileToIdx){
        console.log("TO: ", pileToIdx, "FROM: ", pileFromIdx);piles[pileToIdx].push(piles[pileFromIdx].pop());
        drawPiles(piles);
    }

    function handleDrop(){
        // preventDefault();
        console.log("#### DROP");
        handleDropCardOnNewPile(selectedPile, currDraggedOverPile);
    }

    function handleStackDrop(){
        // get current card being dropped (from the pile)
        // check current item in that stack
        // check if it's the next card 
        // if so, update the stack 
        // and redraw the stacks

        console.log('dropping on stack');

        // TODO: Update this to handle dragging more than the last card on a pile
        var currPile = piles[selectedPile];
        var currCard = currPile[currPile.length - 1];
        var isNextCard = isNextStackCard(stacks[currDraggedOverStack], currCard);

        console.log(">>>> ", stacks[currDraggedOverStack], currCard);

        if(isNextCard){
            updateStacks(currDraggedOverStack, currCard);
            moveCardFromPileToStack(selectedPile, currDraggedOverStack);
            drawPiles();
            drawStacks();
            console.log('is next card');
        } else {
            console.log('no dince');
        }
    }

    function moveCardFromPileToStack(pileFrom, stackTo){
        stacks[stackTo] = piles[pileFrom].pop();
    }

    function isNextStackCard(currCardOnStack, droppingCard){
        if(currCardOnStack.length === 0 && droppingCard[1] === 0){
            return true;
        }

        if(currCardOnStack[1] === droppingCard[1] && currCardOnStack[0] === droppingCard[0] + 1){
            return true;
        }
        return false;
    }

    // when you interact with a pile:
        // drag a card from one pile to another eligible pile
            // drag a card to an empty pile
        // flip the card that's been exposed

    // drag logic - to simply move card without taking into account values

    // pick up the visible card off a pile
    // drag and hover over new pile
    // get the new pile id
    // update the pile state with the new card
    // redraw the piles

    // displaying the pile
        // after the initial deal, the top card should be exposed

    
    init();
    drawPiles(piles);

    // console.log(piles);
    
</script>
</body>
</html>